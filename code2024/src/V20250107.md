## t1 = Î»x.x
bound(t1) = { x }
free(t1) = âˆ…

## t2 = x (Î»x. y)

bound(t2) = { x }
free(t2)  = { y, x }

bound(Î»x .y) = bound(y) âˆª { x } = { x }

## substitution

(Î»x. y)[ x â†¦ y ]
** Î»x is not affected because
   (Î»y. y) is a different function

(Î»x. x)[ x â†¦ y ]
** the body is not affected because
  (Î»x. y) is a different function

(Î»y. y x)[ x â†¦ y ]
  ** cannot substitute directly because
     (Î»y. y y) is a different function

--> (Î»yâ€². yâ€² x)[ x â†¦ y ]
    == (Î»yâ€². yâ€² y)

## Diamond Lemma:
If
M â†’Î²* Mâ‚
M â†’Î²* Mâ‚‚
then
âˆƒ N such that Mâ‚ â†’Î²* N and Mâ‚‚ â†’Î²* N

    M
   / \
  Mâ‚  Mâ‚‚
   \ /
    N

## Lemma
A lambda term M has at most one normal form.
Suppose M has two normal forms Nâ‚ and Nâ‚‚

By def: M â†’Î²* Nâ‚ and Nâ‚ contains no Î² redexes
        M â†’Î²* Nâ‚‚ and Nâ‚‚ contains no Î² redexes
By (CR or diamond lemma) âˆƒ N such that
Nâ‚ â†’Î²* N and Nâ‚‚ â†’Î²* N
So Nâ‚ =Î± Nâ‚‚

## encoding of booleans

IF (Î»xy.x) M N
== (Î»b.b) (Î»xy.x) M N
â†’Î² (Î»xy.x) M N
â†’Î² (Î»y. M) N
â†’Î² M

## Church numerals

[1] = Î»f.Î»x.f x
[2] = Î»f.Î»x. f (f x)

## Successor

SUC [n] â†’Î²* [n+1]
SUC = Î»n. Î»f. Î»x. f (n f x)
   or Î»n. Î»f. Î»x. n f (f x)

## Addition

ADD [m] [n] â†’Î²* [m+n]
ADD = Î»m. Î»n. Î»f. Î»x. m f (n f x)

## test for zero

IF0 = Î»i. i (Î»_. FALSE) TRUE

## pairs

FST (PAIR M N)
== (Î»p. p (Î»xy. x)) (Î»v. v M N)
â†’Î² (Î»v. v M N) (Î»xy. x)
â†’Î² (Î»xy. x) M N
â†’Î²â†’Î² M

## sums

LEFT = Î»m. Î»l. Î»r. l m
RIGHT = Î»m. Î»l. Î»r. r m
CASE = Î»v.v

CASE (LEFT M) L R
â†’Î²* (Î»l. Î»r. l M) L R
â†’Î²â†’Î² L M


## the fixed point theorem

Y = Î» f. (Î»x.f (x x)) (Î»x.f (x x))

Y M
â†’Î² (Î»x.M (x x)) (Î»x.M (x x))
â†’Î² M ((Î»x.M (x x)) (Î»x.M (x x)))
â†Î² M (Y M)

â‡’ Y M is a fixed point of M

## multiplication using fixed point
## Scott encoding
## (xâ€² + 1) * y = y + (xâ€² * y)

## without fixed point, using recursion
mul = Î» x y. CASE_Nat x |Zero| (Î» xâ€². |add| y (mul xâ€² y))

## with fixed point
fâ‚˜ = Î»mul. Î» x y. CASE_Nat x |Zero| (Î» xâ€². |add| y (mul xâ€² y))
|mul| = Y fâ‚˜

### unification / unifier

ğ“” = { Bool â‰ Int }
â‡’ no unifier exists

ğ“” = { Bool â‰ Î± }
â‡’ S = Î± â†¦ Bool  is most general unifier

ğ“” = { Int â†’ Î± â‰ Î² â†’ Bool }
â‡’ S = Î± â†¦ Bool, Î² â†¦ Int


ğ“” = { Int â†’ Î± â‰ Int â†’ Î² }
â‡’ S = Î± â†¦ Î²           is most general unifier
â‡’ Sâ€² = Î± â†¦ T, Î² â†¦ T   is also a unifier for any T
